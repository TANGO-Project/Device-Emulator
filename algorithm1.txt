
Generate the DAG
emulate all tasks on cpu_ref node %cpu_ref has to be the fastest multi-core node (as well as it contains the max # of cores)
calculate rank_u (upward rank) according to the above values
create ready list - if ready(?)==1 then ready

 while ( last task remains unscheduled ) 

	find the next task to schedule, i.e. the task with max upward rank
	find predecessor tasks of each task 
	APPROXIMATE EFT OF ALL NODES for this task (by using T of the cpu_ref) - EFT is computed for 1-thread, 2-thread, ..., max-thread. 
	  The best approximated 1-thread and multi-thread solutions (for each different type node) are recorded to min_single and min_multi, respectively
	Discard nodes that are not efficient for executing this task (emulation is not needed) - Reduce the search space
	
	if ( the remaining nodes are no multi-core cpus ) % if flag==0
		emulate the task on the remaining nodes and find the fastest one
		schedule the task on the fastest node
		update node availability status & ready list

	else  % if the remaining nodes contain at least one multi-core CPU  
		find EST of the remaining nodes
		find the # of avail nodes at that time

		if ( number of ready tasks <= number of available nodes ) % in this case I select the fastest implementation for the candidate multi-core CPUs, no matter how many threads used. 
									  %There is no use to save any core for future execution

		    emulate the task on the remaining nodes and find the fastest one. In the case of multi-core CPU emulate only the fastest approximated between (min_multi, min_single)
		    schedule the task on the fastest node
		    update node availability status & ready list

		else 
			
		      if (rank_u(task) > 1.2 * (minimum rank_u of ready list  ) )  % in that case 
			 emulate on cpu_ref node, the f-thread implementation where f is the max # of threads of the remaining implementations
			 compute the core utilization factor of the cpu_ref node (1-thread Ex Time / max-thread Ex Time)

			    if ( core utilization factor value is large enough )
				update EFT of the remaining solutions - according to the utilization factor found above, update the others
				check if more nodes can be discarded 
				emulate the task on the remaining nodes and find the fastest one. In the case of multi-core CPU emulate only the fastest approximated between (min_multi, min_single)
				schedule the task on the fastest node
				update node availability status & ready list

			    else 
			 	emulate on cpu_ref node, the f/2-thread implementation where f is the max # of threads of the remaining implementations
			 	compute the core utilization factor of the cpu_ref node (1-thread Ex Time / max-thread Ex Time)

			         if ( core utilization factor value is large enough )
					update EFT of the remaining solutions - according to the utilization factor found above, update the others. At this point no more than f/2 thread implemetation exists
						the number of threads = min ( f/2, number of cores in total )
					check if more nodes can be discarded 
					emulate the task on the remaining nodes and find the fastest one. In the case of multi-core CPU emulate only the fastest approximated between (min_multi, min_single)
					schedule the task on the fastest node
					update node availability status & ready list

				 else % nodes are faced only as single-thread
					emulate the task on the remaining nodes and find the fastest one
					schedule the task on the fastest node
					update node availability status & ready list


		       else % nodes are faced only as single-thread
					emulate the task on the remaining nodes and find the fastest one
					schedule the task on the fastest node
					update node availability status & ready list




	



